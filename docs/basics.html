<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>基础使用 - WeChatAuto.SDK</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <!-- 侧边栏 -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>WeChatAuto.SDK</h1>
        <p>微信自动化开发框架</p>
      </div>
      <nav class="sidebar-nav">
        <div class="nav-item">
          <a href="index.html">简介</a>
        </div>
        <div class="nav-group">开始</div>
        <div class="nav-item">
          <a href="getting-started.html">快速上手</a>
        </div>
        <div class="nav-group">指南</div>
        <div class="nav-item">
          <a href="basics.html" class="active">基础使用</a>
        </div>
        <div class="nav-group">API</div>
        <div class="nav-item">
          <a href="api.html">组件 API</a>
        </div>
      </nav>
    </aside>

    <!-- 主内容 -->
    <main class="main-content">
      <h1>基础使用</h1>
      
      <p>本章节将深入介绍 WeChatAuto.SDK 的核心概念和使用方法。</p>

      <h2>UI 自动化原理</h2>
      
      <p>
        WeChatAuto.SDK 基于 <strong>FlaUI</strong> 框架，使用 Windows UI Automation (UIA) 技术
        来实现微信自动化。UIA 是 Microsoft 提供的标准接口，用于访问和操作应用程序的 UI 元素。
      </p>

      <h3>工作原理</h3>
      <ol>
        <li><strong>元素定位：</strong> 通过 AutomationId、Name、ControlType 等属性定位 UI 元素</li>
        <li><strong>元素操作：</strong> 模拟用户操作（点击、输入、滚动等）</li>
        <li><strong>状态监听：</strong> 监听 UI 元素的变化（如新消息到达）</li>
      </ol>

      <div class="alert alert-info">
        <strong>提示：</strong> UI 自动化操作必须在 UI 线程上执行。WeChatAuto.SDK 内部已处理线程切换，
        你无需担心线程安全问题。
      </div>

      <h2>微信元素模型</h2>
      
      <p>WeChatAuto.SDK 将微信窗口抽象为以下层次结构：</p>

      <div class="architecture-diagram">
        <img src="architecture-diagram.svg" alt="微信元素模型" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
        <p style="display:none; color: var(--c-text-lighter);">
          架构图加载失败。请参考文字说明或查看 architecture-diagram.svg 文件。
        </p>
      </div>

      <h3>核心组件说明</h3>
      
      <table>
        <thead>
          <tr>
            <th>组件</th>
            <th>说明</th>
            <th>主要功能</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>WeChatClientFactory</code></td>
            <td>微信客户端工厂</td>
            <td>管理多个微信实例，提供客户端获取方法</td>
          </tr>
          <tr>
            <td><code>WeChatClient</code></td>
            <td>微信客户端</td>
            <td>表示一个微信实例，提供消息发送、搜索等高级操作</td>
          </tr>
          <tr>
            <td><code>WeChatMainWindow</code></td>
            <td>微信主窗口</td>
            <td>封装微信主窗口，包含所有子组件</td>
          </tr>
          <tr>
            <td><code>ChatContent</code></td>
            <td>聊天内容区</td>
            <td>表示一个聊天窗口，包含 ChatHeader 和 ChatBody</td>
          </tr>
          <tr>
            <td><code>ChatBody</code></td>
            <td>聊天主体</td>
            <td>包含消息气泡列表和发送器</td>
          </tr>
          <tr>
            <td><code>MessageBubbleList</code></td>
            <td>消息气泡列表</td>
            <td>管理聊天中的所有消息气泡</td>
          </tr>
          <tr>
            <td><code>Sender</code></td>
            <td>消息发送器</td>
            <td>负责发送消息、文件、表情等</td>
          </tr>
        </tbody>
      </table>

      <h2>常用操作流程</h2>

      <h3>1. 初始化框架</h3>
      <p>首先需要初始化微信自动化框架：</p>
      <pre><code class="language-csharp">var services = new ServiceCollection();
services.AddLogging();
WeAutomation.Initialize(services, options =>
{
    options.DebugMode = true;
});
var serviceProvider = services.BuildServiceProvider();</code></pre>

      <h3>2. 获取微信客户端</h3>
      <p>通过工厂获取微信客户端实例：</p>
      <pre><code class="language-csharp">var factory = serviceProvider.GetRequiredService&lt;WeChatClientFactory&gt;();

// 方式1：通过名称获取
var client = factory.GetWeChatClient("微信昵称");

// 方式2：获取所有客户端
var allClients = factory.GetWxClientList();
foreach (var kvp in allClients)
{
    Console.WriteLine($"客户端：{kvp.Key}");
}</code></pre>

      <h3>3. 打开会话</h3>
      <p>查找并打开指定的好友或群聊：</p>
      <pre><code class="language-csharp">// 查找并打开好友或群聊
var result = client.FindAndOpenFriendOrGroup("好友或群聊名称");
if (result.Success)
{
    Console.WriteLine("会话已打开");
}
else
{
    Console.WriteLine($"打开失败：{result.Error}");
}</code></pre>

      <h3>4. 发送消息</h3>
      <p>使用 Sender 发送消息：</p>
      <pre><code class="language-csharp">// 获取聊天内容区
var chatContent = client.WxMainWindow.MainChatContent;
var sender = chatContent.ChatBody.Sender;

// 发送文字消息
sender.SendMessage("你好！");

// 发送文件
sender.SendFile(new[] { @"C:\path\to\file.txt" });

// 发送表情
sender.SendEmoji("微笑");</code></pre>

      <h3>5. 接收消息</h3>
      <p>监听新消息：</p>
      <pre><code class="language-csharp">var chatBody = chatContent.ChatBody;

// 添加消息监听
chatBody.AddListener(messageContext =>
{
    foreach (var message in messageContext.NewMessages)
    {
        Console.WriteLine($"[{message.MessageTime}] {message.Who}: {message.MessageContent}");
    }
});

// 停止监听
chatBody.StopListener();</code></pre>

      <h2>消息类型</h2>
      
      <p>WeChatAuto.SDK 支持多种消息类型：</p>

      <table>
        <thead>
          <tr>
            <th>消息类型</th>
            <th>说明</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>文字</code></td>
            <td>普通文本消息</td>
          </tr>
          <tr>
            <td><code>图片</code></td>
            <td>图片消息</td>
          </tr>
          <tr>
            <td><code>语音</code></td>
            <td>语音消息</td>
          </tr>
          <tr>
            <td><code>视频</code></td>
            <td>视频消息</td>
          </tr>
          <tr>
            <td><code>文件</code></td>
            <td>文件消息</td>
          </tr>
          <tr>
            <td><code>表情</code></td>
            <td>表情消息</td>
          </tr>
          <tr>
            <td><code>红包</code></td>
            <td>红包消息</td>
          </tr>
          <tr>
            <td><code>引用</code></td>
            <td>引用回复消息</td>
          </tr>
        </tbody>
      </table>

      <h2>聊天类型</h2>
      
      <p>SDK 支持多种聊天类型：</p>

      <pre><code class="language-csharp">public enum ChatType
{
    好友,        // 与好友单聊
    群聊,        // 群聊
    公众号,      // 公众号
    订阅号,      // 订阅号
    服务通知,    // 服务通知
    腾讯新闻,    // 腾讯新闻
    微信团队,    // 微信团队
    其他         // 其他类型
}</code></pre>

      <h2>消息监听机制</h2>
      
      <p>WeChatAuto.SDK 使用轮询机制监听新消息：</p>

      <h3>工作原理</h3>
      <ol>
        <li>定时检查消息气泡列表的变化（默认间隔 1 秒）</li>
        <li>比较当前消息列表与上次的消息列表</li>
        <li>识别新增的消息气泡</li>
        <li>触发回调函数，传递新消息</li>
      </ol>

      <h3>性能优化</h3>
      <ul>
        <li>使用消息气泡的 RuntimeId 作为唯一标识</li>
        <li>只比较最近 5 条消息的哈希值，提高比较效率</li>
        <li>支持并发处理，避免消息丢失</li>
      </ul>

      <h3>监听示例</h3>
      <pre><code class="language-csharp">var chatBody = client.WxMainWindow.MainChatContent.ChatBody;

chatBody.AddListener(messageContext =>
{
    // 处理新消息
    foreach (var newMessage in messageContext.NewMessages)
    {
        // 只处理好友发送的消息（排除系统消息和自己发送的消息）
        if (newMessage.MessageSource == MessageSourceType.好友发送消息)
        {
            Console.WriteLine($"收到来自 {newMessage.Who} 的消息：{newMessage.MessageContent}");
            
            // 自动回复
            if (newMessage.MessageContent == "你好")
            {
                messageContext.Sender.SendMessage("你好！");
            }
        }
    }
});</code></pre>

      <h2>错误处理</h2>
      
      <p>在使用 WeChatAuto.SDK 时，建议添加适当的错误处理：</p>

      <pre><code class="language-csharp">try
{
    var client = factory.GetWeChatClient("微信昵称");
    await client.SendWho("好友名称", "消息内容");
}
catch (WindowNotExsitException ex)
{
    Console.WriteLine($"微信窗口不存在：{ex.Message}");
}
catch (Exception ex)
{
    Console.WriteLine($"操作失败：{ex.Message}");
    // 记录日志
    logger.LogError(ex, "发送消息失败");
}</code></pre>

      <h2>最佳实践</h2>

      <h3>1. 资源管理</h3>
      <p>使用完毕后及时释放资源：</p>
      <pre><code class="language-csharp">using (var factory = serviceProvider.GetRequiredService&lt;WeChatClientFactory&gt;())
{
    var client = factory.GetWeChatClient("微信昵称");
    // 使用客户端...
} // 自动释放资源</code></pre>

      <h3>2. 异常处理</h3>
      <p>微信窗口可能随时关闭，需要处理异常：</p>
      <pre><code class="language-csharp">try
{
    var client = factory.GetWeChatClient("微信昵称");
    if (client.AppRunning)
    {
        await client.SendWho("好友", "消息");
    }
}
catch (Exception ex)
{
    // 处理异常，可能需要重新获取客户端
    Console.WriteLine($"操作失败：{ex.Message}");
}</code></pre>

      <h3>3. 消息监听</h3>
      <p>在消息监听回调中避免长时间阻塞：</p>
      <pre><code class="language-csharp">chatBody.AddListener(messageContext =>
{
    // 快速处理消息
    Task.Run(() =>
    {
        // 耗时操作放在后台线程
        ProcessMessage(messageContext.NewMessages);
    });
    
    // 立即返回，避免阻塞监听线程
});</code></pre>

      <h3>4. 配置优化</h3>
      <p>根据实际需求调整配置：</p>
      <pre><code class="language-csharp">WeAutomation.Initialize(services, options =>
{
    // 生产环境关闭调试模式
    options.DebugMode = false;
    
    // 关闭视频录制（提高性能）
    options.EnableRecordVideo = false;
    
    // 调整消息监听间隔
    options.ListenInterval = 2; // 2秒检查一次
});</code></pre>

      <h2>调试技巧</h2>

      <h3>1. 启用调试模式</h3>
      <pre><code class="language-csharp">options.DebugMode = true;</code></pre>
      <p>启用后会输出详细的调试信息，包括 UI 元素定位过程。</p>

      <h3>2. 启用视频录制</h3>
      <pre><code class="language-csharp">options.EnableRecordVideo = true;
options.TargetVideoPath = @"C:\Videos";</code></pre>
      <p>录制操作视频，方便回放和调试。</p>

      <h3>3. 截图功能</h3>
      <pre><code class="language-csharp">var client = factory.GetWeChatClient("微信昵称");
var screenshotPath = client.CaptureUI("debug-screenshot.png");
Console.WriteLine($"截图保存至：{screenshotPath}");</code></pre>

      <h2>常见问题</h2>

      <h3>Q: 找不到微信客户端怎么办？</h3>
      <p>A: 确保微信 PC 客户端已打开，并且没有被最小化到系统托盘。可以尝试点击系统托盘中的微信图标。</p>

      <h3>Q: 发送消息失败？</h3>
      <p>A: 检查以下几点：</p>
      <ul>
        <li>好友或群聊名称是否正确</li>
        <li>微信窗口是否正常显示</li>
        <li>网络连接是否正常</li>
        <li>查看日志输出获取详细错误信息</li>
      </ul>

      <h3>Q: 消息监听不工作？</h3>
      <p>A: 确保：</p>
      <ul>
        <li>已打开对应的聊天窗口</li>
        <li>监听回调函数没有抛出异常</li>
        <li>检查日志中的错误信息</li>
      </ul>

      <h2>下一步</h2>
      <p>
        了解更多 API 详情，请查看 <a href="api.html">组件 API</a> 文档。
      </p>
    </main>
  </div>
</body>
</html>

